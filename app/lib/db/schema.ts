import { pgTable, serial, text, integer, timestamp, jsonb, date, index, unique } from 'drizzle-orm/pg-core';

/**
 * Users Table - NextAuth v5 Compatible
 * 
 * Stores user accounts for authentication. Schema is compatible with NextAuth v5
 * Adapter requirements for magic link authentication.
 * 
 * Key Features:
 * - UUID-based primary key (text, not serial) - NextAuth generates UUIDs
 * - Email unique constraint for login
 * - emailVerified timestamp tracks email confirmation via magic link
 * - Optional profile fields (name, image) for user personalization
 * 
 * Indexes:
 * - idx_users_email: Optimizes login queries (WHERE email = ?)
 * 
 * References:
 * - Tech Spec: Data Models (users table)
 * - NextAuth Adapter: https://authjs.dev/reference/core/adapters
 */
export const users = pgTable(
  'users',
  {
    id: text('id').primaryKey(), // UUID from NextAuth
    email: text('email').notNull().unique(),
    name: text('name'), // Optional: User's display name
    emailVerified: timestamp('email_verified', { mode: 'date' }), // Nullable: Set when email confirmed
    image: text('image'), // Optional: Profile picture URL
    createdAt: timestamp('created_at', { mode: 'date' }).defaultNow(),
  },
  (table) => ({
    emailIdx: index('idx_users_email').on(table.email),
  })
);

/**
 * Accounts Table - NextAuth v5 Adapter Required
 * 
 * Stores OAuth/Email provider accounts linked to users. Required by DrizzleAdapter.
 * For magic link authentication, this table is not actively used but must exist.
 * 
 * References:
 * - NextAuth Adapter: https://authjs.dev/reference/core/adapters
 */
export const accounts = pgTable('accounts', {
  id: text('id').primaryKey(),
  userId: text('user_id')
    .notNull()
    .references(() => users.id, { onDelete: 'cascade' }),
  type: text('type').notNull(),
  provider: text('provider').notNull(),
  providerAccountId: text('provider_account_id').notNull(),
  refresh_token: text('refresh_token'),
  access_token: text('access_token'),
  expires_at: integer('expires_at'),
  token_type: text('token_type'),
  scope: text('scope'),
  id_token: text('id_token'),
  session_state: text('session_state'),
});

/**
 * Sessions Table - NextAuth v5 Adapter Required
 * 
 * Stores database sessions. With JWT strategy, this table is not actively used
 * but must exist for DrizzleAdapter compatibility.
 * 
 * References:
 * - NextAuth Adapter: https://authjs.dev/reference/core/adapters
 */
export const sessions = pgTable('sessions', {
  sessionToken: text('session_token').primaryKey(),
  userId: text('user_id')
    .notNull()
    .references(() => users.id, { onDelete: 'cascade' }),
  expires: timestamp('expires', { mode: 'date' }).notNull(),
});

/**
 * Verification Tokens Table - NextAuth v5 Adapter Required
 * 
 * Stores magic link tokens. Created when user requests login email,
 * consumed when user clicks the link. Tokens expire after 15 minutes.
 * 
 * References:
 * - NextAuth Adapter: https://authjs.dev/reference/core/adapters
 */
export const verificationTokens = pgTable(
  'verification_tokens',
  {
    identifier: text('identifier').notNull(), // Email address
    token: text('token').notNull().unique(),
    expires: timestamp('expires', { mode: 'date' }).notNull(),
  },
  (table) => ({
    compositePk: unique('verification_tokens_pkey').on(table.identifier, table.token),
  })
);

/**
 * Suggestions Table
 * 
 * Stores lottery suggestions generated by the wheeling engine. Each suggestion
 * contains multiple games (wheeling combinations) for a specific lottery type.
 * 
 * Key Features:
 * - userId foreign key with CASCADE delete (LGPD compliance - right to be forgotten)
 * - value stored in centavos (integer) to avoid floating point errors (R$ 150 = 15000)
 * - games stored as JSONB array for flexibility (wheeling can generate variable number of games)
 * - status enum tracks suggestion lifecycle: pending → realized → verified
 * - contestNumber nullable until user plays and wants verification
 * 
 * JSONB Structure:
 * - games: Array<{ numbers: number[] }> - Each game is an array of lottery numbers
 *   Example: [{ numbers: [3, 12, 18, 27, 34, 45] }, { numbers: [5, 15, 22, 31, 38, 50] }]
 * 
 * Indexes:
 * - idx_suggestions_user_id: Optimizes user's suggestions list query
 * - idx_suggestions_status: Optimizes filtering by pending/verified status
 * 
 * References:
 * - Tech Spec: Data Models (suggestions table)
 */
export const suggestions = pgTable(
  'suggestions',
  {
    id: serial('id').primaryKey(),
    userId: text('user_id')
      .notNull()
      .references(() => users.id, { onDelete: 'cascade' }), // CASCADE delete for LGPD
    lottery: text('lottery').notNull(), // 'megasena' | 'lotofacil'
    value: integer('value').notNull(), // Monetary value in centavos (R$ 150 = 15000)
    games: jsonb('games').notNull(), // Array<{ numbers: number[] }> - Wheeling combinations
    wheelTemplate: text('wheel_template'), // Example: "mega-10-4if4"
    guarantee: text('guarantee'), // Example: "4 if 4" - Minimum prize guarantee
    status: text('status').notNull().default('pending'), // 'pending' | 'realized' | 'verified'
    contestNumber: integer('contest_number'), // Lottery draw number (null until user plays)
    createdAt: timestamp('created_at', { mode: 'date' }).defaultNow(),
    realizedAt: timestamp('realized_at', { mode: 'date' }), // When user marked as played
    verifiedAt: timestamp('verified_at', { mode: 'date' }), // When prizes were checked
  },
  (table) => ({
    userIdIdx: index('idx_suggestions_user_id').on(table.userId),
    statusIdx: index('idx_suggestions_status').on(table.status),
  })
);

/**
 * Lottery Results Table
 * 
 * Stores official lottery draw results synced from Caixa Econômica Federal API.
 * Used for automatic prize verification against user suggestions.
 * 
 * Key Features:
 * - drawNumbers stored as PostgreSQL integer array (native array type, not JSONB)
 * - Unique constraint on (lottery, contestNumber) prevents duplicate entries (idempotent sync job)
 * - prizes stored as JSONB for flexibility (different lotteries have different prize tiers)
 * - drawDate is date type (without time) for easier filtering
 * 
 * Array Format:
 * - drawNumbers: integer[] - Example for Mega Sena: [3, 12, 18, 27, 34, 45]
 * - PostgreSQL arrays are 1-based but Drizzle handles conversion to 0-based JavaScript arrays
 * 
 * JSONB Structure:
 * - prizes: { sena?: number, quina?: number, quadra?: number, ... }
 * - Values in centavos (integer). May be null if prize data not available yet.
 * 
 * Indexes:
 * - idx_lottery_results_lottery: Optimizes filtering by lottery type (megasena/lotofacil)
 * - idx_lottery_results_draw_date: Optimizes sorting by recent results
 * - uq_lottery_results_contest: Unique constraint prevents duplicate contest entries
 * 
 * References:
 * - Tech Spec: Data Models (lottery_results table)
 */
export const lotteryResults = pgTable(
  'lottery_results',
  {
    id: serial('id').primaryKey(),
    lottery: text('lottery').notNull(), // 'megasena' | 'lotofacil'
    contestNumber: integer('contest_number').notNull(), // Draw number (e.g., 2756)
    drawNumbers: integer('draw_numbers').array().notNull(), // Winning numbers as integer[]
    drawDate: date('draw_date', { mode: 'date' }).notNull(), // Date of draw (no time)
    prizes: jsonb('prizes'), // Prize tiers and values in centavos (nullable)
    createdAt: timestamp('created_at', { mode: 'date' }).defaultNow(),
  },
  (table) => ({
    uniqueContest: unique('uq_lottery_results_contest').on(table.lottery, table.contestNumber),
    lotteryIdx: index('idx_lottery_results_lottery').on(table.lottery),
    drawDateIdx: index('idx_lottery_results_draw_date').on(table.drawDate),
  })
);

/**
 * Prizes Table
 * 
 * Stores detected prizes from verified user suggestions. Each entry represents
 * a winning game within a suggestion (a suggestion can have multiple games).
 * 
 * Key Features:
 * - suggestionId foreign key with CASCADE delete (when suggestion deleted, prizes deleted too)
 * - gameIndex identifies which game in the suggestion won (0-based array index)
 * - matchedNumbers stored as PostgreSQL integer array
 * - viewedAt tracks if user has seen the prize notification (for "new" badge)
 * 
 * Prize Detection Logic:
 * - Automatic verification job compares suggestion.games against lottery_results.drawNumbers
 * - Creates prize entry for each winning game with matched numbers
 * - prizeTier determined by count of matched numbers (e.g., 6 matches = 'sena')
 * - prizeValue estimated from lottery_results.prizes (may be null if exact value unknown)
 * 
 * Array Format:
 * - matchedNumbers: integer[] - Subset of drawNumbers that matched
 *   Example: [3, 12, 18, 27] means these 4 numbers matched (quadra prize)
 * 
 * Indexes:
 * - idx_prizes_suggestion_id: Optimizes listing all prizes for a suggestion
 * 
 * References:
 * - Tech Spec: Data Models (prizes table)
 */
export const prizes = pgTable(
  'prizes',
  {
    id: serial('id').primaryKey(),
    suggestionId: integer('suggestion_id')
      .notNull()
      .references(() => suggestions.id, { onDelete: 'cascade' }), // CASCADE delete
    gameIndex: integer('game_index').notNull(), // Which game in suggestion.games won (0-based)
    contestNumber: integer('contest_number').notNull(), // Which lottery draw won
    prizeTier: text('prize_tier').notNull(), // 'sena' | 'quina' | 'quadra' | 'quinze' | etc
    prizeValue: integer('prize_value'), // Estimated prize value in centavos (nullable)
    matchedNumbers: integer('matched_numbers').array().notNull(), // Numbers that matched
    viewedAt: timestamp('viewed_at', { mode: 'date' }), // When user saw notification (nullable)
    createdAt: timestamp('created_at', { mode: 'date' }).defaultNow(),
  },
  (table) => ({
    suggestionIdIdx: index('idx_prizes_suggestion_id').on(table.suggestionId),
  })
);
